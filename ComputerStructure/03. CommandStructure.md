# 명령어의 구조

- 연산 코드(operation code), 연산자
    - 명령어가 수행할 연산

- 오퍼랜드(operand), 피연산자
    - 연산에 사용할 데이터 또는 데이터가 저장된 위치
    - 연산에 사용할 데이터를 직접 명시하기보다는 데이터가 저장된 위치를 명시한다.

## 오퍼랜드
- 오퍼랜드 필드, 주소 필드
    - 메모리 주소나 레지스터 이름이 담긴다.


- 오패랜드의 개수에 따라 **0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어**라 불린다.

<img src="https://velog.velcdn.com/images/thdgusrbek/post/93c23bf3-825c-414f-bed1-ad875e8c2ffe/image.png"/>

## 연산코드

1. 데이터 전송
    - MOVE, STORE, LOAD(FETCH), PUSH, POP
2. 산술/논리 연산
    - ADD, SUBTRACT, MULTIPLY, DIVIDE ...
3. 제어 흐름 변경
    - JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
4. 입출력 제어
    - READ(INPUT), WRITE(OUTPUT), START IO, TEST IO

---

## 주소 지정 방식
- 연산에 사용할 데이터를 직접 명시하기보다는 데이터가 저장된 위치를 명시한다.

    -> **유효 주소를 찾는 방법**

<details>
<summary> 명령어 길이 때문 </summary>
<div markdown="1">
    하나의 명령어가 n비트로 구성되어 있을 때, 연산 코드 필드가 m비트라고 하면 1-주소 명령어일 때, 오퍼랜드 필드의 길이는 n-m비트가 된다. 오퍼랜드 개수가 늘어나면 필드의 길이는 더욱 작아진다. 그래서 오퍼랜드 필드 안에 메모리 주소를 담아 표현할 수 있는 데이터의 크기를 크게 할 수 있다.
</div>
</details>

## 유효 주소(Effective Address)
- 연산 코드에 사용할 데이터가 저장된 위치

## 1. 즉시 주소 지정 방식
    
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 장점 : 빠르다.
- 단점 : 표현할 수 있는 데이터의 크기가 작아진다.

<img src="https://i.imgur.com/2mC8wvI.png"/>

## 2. 직접 주소 지정 방식

- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 장점 : 즉시 주소 지정 방식보다 데이터 크기는 커졌다.
- 단점 : 유효 주소를 표현할 수 있는 범위는 n-m비트이다. (유효 주소에 제한이 생긴다.)

<img src="https://i.imgur.com/Xwm6uZQ.png" />

## 3. 간접 주소 지정 방식

- 유효 주소의 주소를 오퍼랜드 필드에 명시한다.
- 장점 : 직접 주소 지정 방식보다 유효 주소 범위가 넓어졌다.
- 단점 : 두 번의 메모리 접근이 필요하여 앞 방식보다 느리다.

<img src="https://i.imgur.com/rJLsblW.png"/>

## 4. 레지스터 주소 지정 방식

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
- 장점 : 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.
    - CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.
- 단점 : 레지스터 크기에 제한이 생길 수 있다.

<details>
<summary> 메모리와 레지스터 비교 </summary>
<div markdown="1">

레지스터와 메모리의 용량 크기를 비교하기 위해서는 각각의 기본 개념과 용도를 이해하는 것이 중요합니다.

1. **레지스터(Register):**
   - 레지스터는 컴퓨터 프로세서 내부에 위치한 매우 빠른 메모리입니다.
   - 그 크기는 매우 작으며, 일반적으로 수십 바이트에서 몇 킬로바이트 정도입니다.
   - 레지스터는 현재 실행 중인 작업에 필요한 데이터나 명령어를 일시적으로 저장하는 데 사용됩니다.
   - 프로세서의 속도와 직접적으로 관련이 있어서 매우 빠른 데이터 접근 속도를 가집니다.

2. **메모리(주 기억장치 또는 RAM):**
   - 메모리는 컴퓨터의 주 기억장치로, 프로그램과 현재 사용 중인 데이터를 저장합니다.
   - 메모리의 크기는 일반적으로 몇 기가바이트(GB)에서 수십 GB에 이릅니다.
   - 메모리는 레지스터보다는 느리지만, 하드 드라이브보다는 훨씬 빠른 접근 속도를 가지고 있습니다.
   - 메모리는 임시 저장 공간으로 사용되며, 컴퓨터가 꺼지면 그 내용이 사라집니다(휘발성).

**비교:**
- **용량:** `메모리(RAM)의 용량은 레지스터보다 훨씬 큽니다. 레지스터는 매우 제한된 용량을 가지고 있으며, 주로 현재 처리 중인 명령어나 데이터를 임시적으로 저장하는 데 사용됩니다.`
- **속도:** 레지스터는 메모리보다 훨씬 빠른 속도로 데이터에 접근할 수 있습니다. 이는 레지스터가 프로세서 내부에 위치해 있기 때문입니다.
- **용도:** 레지스터는 빠른 연산과 임시 데이터 저장을 위해, 메모리는 프로그램 실행과 데이터 처리를 위해 사용됩니다.

결론적으로, 레지스터와 메모리는 용량과 속도, 용도 면에서 서로 다른 특성을 가지고 있습니다. 레지스터는 속도가 매우 빠르지만 용량이 작고, 메모리는 상대적으로 큰 용량을 가지지만 레지스터보다는 느린 접근 속도를 가집니다.
</div>
</details>

<img src="https://velog.velcdn.com/images/97gkswn/post/fd79e9e4-072b-4ef7-9c3f-ef568d553f70/image.png"/>

## 5. 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효주소)를 저장한 레지스터를 오퍼랜드 필드에 명시한다. 
- 장점 : 메모리에 접근하는 횟수는 한번으로 줄어들어 간접 주소 지정 방식보다 빠르다.
- 단점 
    - 여전히 직접 주소 지정 방식에 비해서 속도가 느리다.
    - 레지스터의 제한된 수

<img src="https://i.imgur.com/G3tcFSd.png"/>

