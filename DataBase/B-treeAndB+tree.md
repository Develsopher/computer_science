# B-트리와 B+트리 🌳🔍

데이터베이스의 인덱스를 구성하는 데 있어서 B-트리와 B+트리는 굉장히 중요한 알고리즘입니다. 과거에 많이 사용하였던 BST(AVL)트리 등과 비슷하지만 다른 이 구조들은 DB의 효율성을 크게 향상시키며, 그 덕분에 자주 사용됩니다.
아래는 본문에 들어가기 전에 이해해야 할 문장입니다. BST와 비교하여 설명하겠습니다.

- DB에서 데이터를 조회할 때 secondary storage(SSD, HDD 등)에 최대한 적게 접근하는 것이 성능면에서 좋습니다.
- block 단위로 읽고 쓰기 때문에 연관된 데이터를 모아서 저장하면 더 효율적으로 읽고 쓸 수 있습니다.

## B-트리 (Balanced Tree)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxJDXW%2FbtrIOvQhZUc%2Ft7gUcEAAC1Yh9xuLaRQUE0%2Fimg.jpg">

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqiMTZ%2FbtrIy92zPxR%2FBtENZu19UQlqelAfpOL8yK%2Fimg.png">

##### 출처 : https://algopoolja.tistory.com/122

B-트리는 모든 데이터가 정렬된 상태로 유지되는 균형 잡힌 트리입니다. 각 노드는 `두 개 이상의 자식을 가질 수 있어 (최대 3~5개)` Binary-Tree와는 다릅니다. 또한 `노드의 데이터 수` 역시 1개인 AVL 트리와 달리 `2개 이상 가질 수 있어 (최대 2~4개)` block 활용성 면에서 앞섭니다. Balanced-Tree, 즉 '균형 잡힌 트리'를 의미하는 B-트리는 검색 속도를 극대화하기 위해 설계되었습니다.

### B-트리의 특징:

- 모든 리프 노드는 동일한 레벨에 위치하여 균형을 이룹니다.
- 검색, 삽입, 삭제 작업을 `O(log n)` 시간 안에 수행할 수 있습니다.
- 노드가 변경될 경우 재정렬이 필요하지만, 빠른 검색 속도를 위한 타협점입니다.

## B+트리
<img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*vQWSOWC7jhz_Rvw81P2Qaw.png">

##### 출처 : https://vipulpachauri12.medium.com/how-mysql-stores-data-in-disk-ee51a9e81c39

MySQL의 InnoDB와 같은 시스템에서 사용되는 B+트리는 트리의 높이를 낮추고, 풀 스캔의 속도를 빠르게 하는 특징이 있습니다. 리프 노드에만 데이터를 저장하여 더 많은 키를 한 블록에 저장할 수 있습니다.

### B+트리의 특징:

- 리프 노드에만 데이터를 저장하여 높이를 낮출 수 있습니다.
- 리프 노드끼리 더블 링크드 리스트로 연결되어 있어 순차적인 접근이 용이합니다.
- 중복된 키를 허용하여 리프 노드에서의 데이터 접근을 최적화합니다.

## B-트리와 B+트리 비교

| 특징               | B-트리                                                         | B+트리                                                         |
|--------------------|----------------------------------------------------------------|----------------------------------------------------------------|
| 데이터 저장 위치     | 내부 노드와 리프 노드 모두                                      | 오직 리프 노드에만 데이터 저장, 내부 노드는 키와 포인터만 저장       |
| 트리의 높이         | B+트리에 비해 상대적으로 높을 수 있음                              | 더 많은 키를 담을 수 있어 B-트리보다 높이가 낮아짐, 따라서 탐색에 필요한 디스크 I/O 감소 |
| 검색 성능           | 비균일 검색에 유리: 근접한 키를 빠르게 접근                         | 균일 검색에 유리: 모든 리프 노드가 같은 레벨에 있어 일정한 탐색 성능 제공   |
| 키 중복             | 키 중복 없음                                                   | 키가 내부 노드와 리프 노드에 중복될 수 있음, 리프 노드에 모든 데이터가 존재 |
| 풀 스캔 성능        | 모든 노드를 탐색해야 함                                        | 리프 노드를 순차적으로 탐색, 따라서 풀 스캔이 더 빠름                |
| 공간 효율성         | 리프 노드에만 데이터를 저장하는 B+트리에 비해 낮을 수 있음             | 한 노드에 더 많은 키를 저장할 수 있어 공간 효율성이 높음              |
| 데이터 삽입/삭제 성능 | 리프 노드에 데이터가 분산되어 있어 재배치가 덜 필요할 수 있음            | 리프 노드에만 데이터가 저장되므로, 삽입이나 삭제 시에 리프 노드의 재배치가 필요할 수 있음 |
| 노드 연결 구조       | 일반적으로 노드 간 링크드 리스트 사용 안 함                        | 리프 노드들이 링크드 리스트로 연결, 범위 검색과 순차 접근을 용이하게 함   |


##### 도움 받은 자료 : https://www.youtube.com/watch?v=liPSnc6Wzfk