# 데이터베이스 정규화: Normalization 🚀

| 단계 | 정규화 조건 | 목적 | 예시 |
| --- | --- | --- | --- |
| 제1 정규화 (1NF) | 컬럼의 원자성 보장 | 중복 제거 및 데이터 무결성 유지 | 다중값 속성 분해 |
| 제2 정규화 (2NF) | 부분 함수 종속성 제거 | 데이터 구조의 논리성 확립 | 복합키에서 부분 종속 속성 분해 |
| 제3 정규화 (3NF) | 이행적 종속성 제거 | 갱신 이상 방지 및 데이터 독립성 확립 | 이행적 종속 속성 분해 |
| BCNF (보이스-코드 정규형) | 모든 결정자가 후보키 | 더 강한 무결성 조건의 확립 | 결정자가 후보키가 아닌 경우 분해 |
| 제4 정규화 (4NF) | 다중값 종속성 제거 | 관계의 논리성 확립 | 다중값 종속성 속성 분해 |
| 제5 정규화 (5NF) | 조인 종속성 제거 | 복잡한 관계에서의 무결성 유지 | 복잡한 구조의 테이블 분해 |

>💡 원부이결다조 ??

## 정규화란? 🤔

정규화는 데이터베이스를 설계하는 과정에서 데이터 중복을 최소화하고, 데이터 구조를 개선하여 데이터베이스의 무결성을 보장하는 방법론입니다. 이를 통해 데이터베이스는 더욱 효율적이고, 오류 발생 가능성이 줄어듭니다.
책에서는 4정규화와 5정규화는 다루지 않으므로 예시는 BCNF까지만 다루겠습니다.

---

### 제1 정규화 (1NF) 💡

- <mark>목적</mark>: 데이터 테이블에서 각 컬럼의 값이 `원자적이고 유일하게` 만드는 것입니다.
- 조건: 모든 컬럼에 원자적인 값이 들어가며, 각 레코드는 유일해야 합니다.

예시:

- 다음과 같은 고객 취미 테이블이 있을 때, 원자성을 보존해 줄 수 있습니다.

`Before`

| 이름 | 취미  |
| --- | ---- |
| 김땡땡 | 낚시 |
| 이땡땡 | 이발 |
| 박땡땡 | 쇼핑, 폭식 |
| 최땡땡 | 주식, 투기 |
| 정땡땡 | 음주 |

`After`

| 이름 | 취미  |
| --- | ---- |
| 김땡땡 | 낚시 |
| 이땡땡 | 이발 |
| 박땡땡 | 쇼핑 |
| 박땡땡 | 폭식 |
| 최땡땡 | 주식 |
| 최땡땡 | 투기 |
| 정땡땡 | 음주 |


### 제2 정규화 (2NF) 🚗

- <mark>목적</mark>: `1NF를 만족`하며, 모든 비주요 컬럼이 기본키에 완전 함수적 종속을 만족하는 것입니다. (`부분적 함수 종속 제거`)
- 조건: 기본키가 복합키인 경우, 모든 비주요 컬럼이 그 복합키 전체에 대해서만 종속되어야 합니다.

예시:

- 강의 관련 테이블에서 기본키는 (학생번호, 강의명)으로 복합키입니다.
- 또한, 이 두 키는 성적을 결정하고 있습니다. (학생번호, 강좌명) -> (성적)
- 그런데 강의실이라는 컬럼은 기본키의 부분집합인 강의명에 의해 결정 될 수 있습니다. (강의명) -> (강의실) (* 학생 번호가 굳이 필요 없음)
- 기본키(학생번호, 강의명)의 부분키인 강의명이 결정자이기 때문에 강의실을 분해하여 별도의 테이블로 관리함으로 제2 정규형을 만족 시킬 수 있습니다.


`Before`

| 학생 번호 | 강의명 | 강의실  | 성적  |
| --- | --- | --- | --- |
| 101 | CS전공지식 | 큰돌관 | 1.0 |
| 102 | JPA프로그래밍 | 영한관 | 1.5  |

`After`

| 학생 번호 | 강의명  | 성적  |
| --- | ---  | --- |
| 101 | CS전공지식 |  1.0 |
| 102 | JPA프로그래밍 |  1.5  |

| 강의명 | 강의실  |
| --- | --- |
| CS전공지식 | 큰돌관 |
| JPA프로그래밍 | 영한관 |



### 제3 정규화 (3NF) ✈️

- <mark>목적</mark>: `2NF를 만족`하며, 모든 비주요 컬럼이 기본키에 `이행적 종속이 없어`야 하는 것입니다.
    - (* 이행적 종속  : A -> B, B -> C 가 성립할 때, A -> C가 성립되는 것)
- 조건: 비주요 컬럼이 다른 비주요 컬럼에 의존하지 않고, 오직 기본키에만 의존해야 합니다.

예시:

- (학생번호)는 (강의명)을 결정하고 있고, (강의명)은 (수강료)를 결정하고 있습니다.
- (학생번호)와 (수강료)는 관계가 없습니다.
- 그렇기 때문에 두 테이블로 나누어야 합니다.

`Before`

| 학생 번호 | 강의명 | 수강료  |
| --- | --- | --- |
| 101 | CS전공지식 | 100만원 |
| 102 | JPA프로그래밍 | 200만원 |

`After`

| 학생 번호 | 강의명 |
| --- | --- |
| 101 | CS전공지식 |
| 102 | JPA프로그래밍 |

| 강의명 | 수강료  |
| --- | --- |
| CS전공지식 | 100만원 |
| JPA프로그래밍 | 200만원 |



### 보이스-코드 정규형 (BCNF) 🎯

- <mark>목적</mark>: 3NF에서도 해결되지 않는 결정자에 대한 종속성 문제를 해결하기 위해,  `모든 결정자가 후보키`가 되도록 하는 것입니다.
- 조건: 모든 결정자가 후보키 내에 있어야 합니다.

예시:

- (학생 ID)와 (특강 이름)이 복합 기본키입니다.
- (교수)가 (특강 이름)을 결정합니다.
- 여기서 (교수)는 후보키가 되어야 하며, 그렇지 않은 경우 분해가 필요합니다.
    - (후보키 : 각 테이블의 레코드를 유일하게 식별할수 있는 속성의 집합)

`Before`

| 학생번호 | 특강 이름 | 교수 |
| --- | --- | --- |
| 101 | CS전공지식 | 주큰돌 |
| 102 | CS전공지식 | 주큰돌 |
| 103 | 스프링 원리 | 목금토비 |
| 104 | JPA프로그래밍 | 우아한 |

`After`

| 학생번호 | 교수 |
| --- | --- |
| 101 | 주큰돌 |
| 102 | 주큰돌 |
| 103 | 목금토비 |
| 104 | 우아한 |


| 특강 이름 | 교수 |
| --- | --- |
| CS전공지식 | 주큰돌 |
| 스프링 원리 | 목금토비 |
| JPA프로그래밍 | 우아한 |


## 정규화의 장점 🌈

- **데이터 중복 감소**: 중복 데이터가 줄어들어 저장 공간 효율성이 증가합니다.
- **데이터 무결성 유지**: 오류 가능성이 줄고, 데이터의 일관성이 유지됩니다.
- **쿼리 성능 향상**: 잘 구조화된 데이터베이스는 쿼리 성능을 향상시킵니다.

## 정규화의 단점 🌧️

- **조인의 복잡성 증가**: 테이블이 분리되면서 조인 연산이 복잡해질 수 있습니다.
- **성능 저하 가능성**: 특정 상황에서는 조인으로 인한 성능 저하가 발생할 수 있습니다.

## 결론 🎯

데이터베이스 정규화는 데이터 무결성과 효율성을 위한 중요한 과정입니다. 적절한 정규화 수준을 선택하는 것이 중요하며, 사용 사례에 따라 이상적인 정규화 수준이 달라질 수 있습니다.