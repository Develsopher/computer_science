## 자바스크립트의 데이터 타입은 두가지로 분류된다

---

자바스크립는 두가지의 데이터 타입을 가진다. 바로 **원시(Primitive)타입 데이터** 와 **참조(Reference)타입 데이터**이다. 어떤 기준으로 타입을 분류하게 되는것일까?

- **데이터 변경여부**
  - 원시타입은 변경 불가능한 값이다.
  - 참조타입은 변경 가능한 값이다.
- **변수에 저장되는값** (메모리 주소가 할당되어있는 메모리의 공간)
  - 원시타입은 실제 값이 저장된다.
  - 참조타입은 참조 값이 저장된다.
- **데이터가 전달되는 방법** (값이 할당된 변수를 다른 변수에 할당시킬때)

  - 원시타입은 원시값이 복사되어 저장된다.
  - 참조타입은 참조 값 (데이터가 위치하고 있는 메모리주소)이 저장된다.

  각각의 특징을 간략하게 비교해보았다. 이제 타입별로 자세히 알아보자.

## 원시(Primitive)타입 데이터

---

### **변수에 저장된 데이터는 변경이 불가능하다**는 의미가 무엇일까?

예를들어 `let a = 10` 변수 a에 숫자리터럴 10을 할당을 하였고 다음 줄에 `a = 11`이렇게 작성한다면 데이터가 변경되는거 아닐까?라고 생각할 수 있다. 하지만 이것은 변수 a에 값이 10이 할당되었다가 11이 **재할당**되는 것 뿐이다. 즉, 메모리에 저장된 데이터 10, 11은 변경할 수 없다.(Read Only) 예시를 이미지로 이해해보자.

![step1](https://github.com/Develsopher/computer_science/assets/78126381/6dcb6b34-bcac-4128-9b7c-df40ce412f48)


변수 a는 단지 메모리주소(0x00000F2, 0x901000F)가 너무 길고 복잡하기 때문에 `a`라는 이름을 부여한 것이다. 처음 메모리주소가 지정된 메모리 공간에 **10**이 할당되고 **11**을 변수에 재할당하고자 하면 변수`a`는 다른 메모리 주소값을 가진다.

여기서 중요한 점은 한번 메모리에 저장된 **원시 데이터**는 **변경 불가능**하며 **읽기 전용**이다. 이는 데이터의 신뢰성을 보장할 수 있다.

cf)그럼 한번 저장된 데이터는 메모리에 무한정 쌓이게 되서 메모리 성능을 걱정할 수 있다. 하지만 컴퓨터의 메모리는 `가비지 컬렉터`에 의해 쓰지 않는 데이터는 정리한다. 특정시간 마다 최적화 작업을 한다.

### 문자열의 경우를 한번 살펴보자

문자열또한 원시타입 데이터이다. 하지만 문자열은 다른 원시타입과 조금 특이한 점이 있다. 바로 **유사배열 객체**라는 점이다. 분명 원시타입이지만 배열과 유사하게 각 문자에 접근이 가능하다.

```javascript
let str = 'hello';

console.log(str.length); //5, 마치 객체처럼 length 프로퍼티를 가진다.

console.log(str[1]); //e, 인덱스 이용해서 각각의 문자에 접근할 수 있다.
```

하지만 이와 동시에 문자열은 원시 타입의 **데이터 불변성**규칙을 따른다.

```javascript
let string = 'hello';

string[1] = 'p';

console.log(string); // 'hello', 변경되지 않는다.
```

### 원시타입 데이터는 값에 의해 전달된다.

변수에 값이 할당되어 있고 변수자체는 할당된 값을 의미한다. 그럼 처음 변수를 다른 변수에 할당되면 어떻게 될까? 예시로 살펴보자.

```javascript
let apple = true;
let banana = apple;

console.log(apple); // true
console.log(banana); // true

banana = false;

console.log(apple === banana); // false ,  true === false의 결과는 false이다.
```

apple에 할당되었던 불리언값 **true**는 banana 변수에 **true** 값 그자체로 복사되어 전달이 된다. 따라서 apple과 banana는 **각각의 불리언 데이터** true를 가지게 된다.

![step2](https://github.com/Develsopher/computer_science/assets/78126381/ce8cc01a-7240-485a-a87f-b7c2ca9a7400)


따라서 각각의 변수에 다른값을 재할당하여도 서로의 데이터에는 영향을 끼치지 않는다.

## 참조(Reference)타입 데이터

---

자바스크립트는 **프로토타입 기반의 객체지향**프로그래밍 언어이다.

사실 일상의 대부분의 정보들은 객체(key와 value)조합으로 모두 표현이 가능하다. 다른 말로 우리가 프로그래밍을 하는이상 객체와 떨어질래야 떨어질 수 없는 사이일 것이다.

따라서, 자바스크립트에서 객체를 일컫는 **참조 데이터 타입**은 중요한 데이터 타입이기도 하다.

```javascript
let obj = {};
obj['name'] = 'june';
console.log(obj); // { name: 'june' }
```

빈 객체를 변수에 할당해주었고 추후에 얼마든지 **프로퍼티**를 추가할 수 있다. 이는 객체는 얼마든지 동적으로 크기가 늘 수 있기때문에 크기를 한정할 수 없음을 의미한다.

원시타입 데이터의 경우를 살펴보자. 자바스크립트는 데이터 할당을 할때 데이터 타입을 별도로 명시하진 않지만 자바스크립트 엔진은 데이터의 종류를 파악하고 값이 저장될 메모리의 공간을 적절하게 확보해둔다.

하지만, 객체 타입 데이터는 데이터를 저장해도 해당 데이터가 얼마나 클지 파악할 수 없다. (그것은 사용자만이 알고 있으니) 그렇기 때문에 객체 데이터는 메모리의 `힙(heap)`영역에 따로 저장이 된다. 그리고 **힙영역의 메모리 주소**가 각각의 변수에 저장된다.

우리는 이것을 **변수00는 객체를 참조하고 있다.** 또는 **객체를 가르키고 있다**라고 하게 되는것이다.

### 참조 데이터는 변경이 가능하다

예시로 살펴보자.

```javascript
let fruit = {
  name: 'apple',
};

fruit.name = 'banana'; //프로퍼티 동적 변경
fruit.count = 3; // 프로퍼티 동적  생성
```

변수 `fruit`은 힙영역에 담겨 있는 메모리주소를 가르킨다. 해당 메모리 주소를 통해 객체에 직접 접근이 가능하다. `fruit.name`을 통해 객체에 있는 프로퍼티들에 접근을 할 수 있다. 예시처럼 프로퍼티를 동적 변경, 생성, 삭제 등의 행위를 할 수 있고 **참조 데이터는 변경이 가능함**을 의미한다.

![step3](https://github.com/Develsopher/computer_science/assets/78126381/e87b4eaa-69bb-4eac-8bd4-fcf36d2def1f)


객체의 크기는 가늠할 수 없기때문이고 실제로 크기도 클 수 있기때문에 메모리의 성능을 위해 하나의 객체를 참조하는 방식이다.

### 참조타입 데이터는 참조에 의해 전달된다.

하나의 변수에 특정 객체를 할당하였다고 가정해보자. 그리고 그 변수를 또다른 변수에 할당해보자.
원시타입 데이터의 경우는 두 변수가 값은 같지만 엄연히 다른 메모리 공간에 존재하고 있는 데이터 였다. 하지만 반대로 이경우는 하나의 공간에 있는 객체를 바라보며 **동일한 참조값**이 변수에 저장이 된다.

```javascript
let fruit = {
  name: 'apple',
};

let meat = fruit;

console.log(meat === fruit); //객체가 담겨져 있는 메모리 주소값이 같음
```

![step4](https://github.com/Develsopher/computer_science/assets/78126381/8541f6f5-2e3d-4b44-aaeb-81b6a861dcf4)


이는 프로그램밍을 하면서 꽤나 유의깊게 살펴봐야 한다.

왜냐하면 새로운 변수에 객체를 할당하였고 새로운 변수를 통해 **프로퍼티 접근에 따른 조작**하게 될 경우 원본 변수에도 영향을 주기 때문이다.

```javascript
let fruit = {
  name: 'apple',
};

let meat = fruit;

meat.name = 'fork'; // meat변수를 통해 프로퍼티 조작
meat.count = 1;

console.log(meat); //{ name: 'fork', count: 1 }

console.log(fruit); //{ name: 'fork', count: 1 }
```

위의 경우를 본다면 분명 `meat`변수에 담긴 데이터만 변경을 원했지만 의도치않게 `fruit`변수의 데이터까지 변경하게 된 것이다. 이러한 의도치 않음은 프로그래밍에 있어 큰 오류를 가져다 줄 수 있다.

동일한 참조값이 변수에 담겨져 있기 때문에 서로의 프로퍼티 조작이 영향을 주게 된다.

이것을 바로 **얉은 복사**가 되었기 떄문이라고 한다.

각각의 변수의 참조 데이터가 서로 영향을 받지 않기 위해서는 **깊은 복사**가 필요하다.

## 얕은복사 그리고 깊은복사

---

위에서 언급하긴 하였지만 정확히 `얕은 복사`가 무엇이며 의미하는 바가 무엇일까?

얕은 복사를 다음과 같이 정의해보았다.

> 새로운 변수에 기존 변수에 있는 값을 **복사**할때 두 변수간의 **독립성**을 보장하지 못한다.

반대로 `깊은 복사`는 다음과 같다.

> 새로운 변수가 기존 변수로 부터 값을 **복사**할때 각각의 데이터들이 **독립성**을 보장할 수 있다.

```javascript
let obj = {
  a: 1,
};

let obj2 = obj;

console.log(obj2 === obj); // 얕은 복사

let number = 10;

let number2 = number;

console.log(number2 === number); // 깊은 복사
```

값이 변수`obj2`에 복사는 되긴 되었지만 `obj2`의 프로퍼티 조작으로 원본 객체 데이터를 변경할 수 있으므로 **얕은 복사**에 해당한다.

### 참조 타입 데이터를 깊은 복사 하는 방법

대표적인 방법은 **스프레드 문법**을 활용하는것이다.

```javascript
let obj = {
  a: 1,
};

let obj2 = { ...obj };

console.log(obj2); // {a:1}, 값 자체는 obj에 담긴 객체와 같다.

console.log(obj2 === obj); //false,  하지만 변수에 담긴 참조값 주소는 다르다

obj2.a = 10;
console.log(obj); // obj의 독립성을 유지했다. (깊은 복사를 해서 가능)
```

하지만, **중첩된 객체**에서 한계는 곧 바로 들어난다.

```javascript
const obj = {
  inner_obj: {
    a: 10,
  },
};

const obj2 = { ...obj };

console.log(obj2 === obj); // 값은 같지만 가르키는 메모리 주소가 다르기때문에

console.log(obj2.inner_obj === obj.inner_obj); // 값도 같고 가르키는 메모리 주소가 같다. (얕은 복사)

obj2.inner_obj.a = 11;

console.log(obj2); // { inner_obj: { a: 11 } }
console.log(obj); // { inner_obj: { a: 11 } }
```

중첩된 상태에서는 깊은 복사를 수행하지 못한다.

해결책은 간편하게 `lodash`라는 라이브러리를 활용하는 방법이 있다.

```javascript
const _ = require('lodash');

const obj2 = _.cloneDeep(obj);

console.log(obj2 === obj); // false, 값은 같지만 바라보는 주소가 다르기 때문에
console.log(obj2.inner_obj === obj.inner_obj); // false, 값은 같지만 바라보는 주소가 다르기 때문에
```
