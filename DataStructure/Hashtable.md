# Hashing
해싱이란 임의의 길이의 값을 해시 함수(Hash Function)을 사용하여 고정된 크기의 값으로 변환하는 작업

# Hash Table
해싱을 사용하여 데이터를 저장하는 자료 구조
BST(Binary Search Tree)나 Array에 비해 굉장히 빠른 속도로 탐색, 삽입, 삭제 가능
해시 함수를 사용하여 변환한 갑을 색인(Index)으로 삼아 키(Key)와 데이터(Value)를 저장하는 자료 구조

연산 종류 : Search, Insert, Delete

해시 함수를 사용하여 특정 해시값을 알아내고 그 해시값을 인덱스로 변환하여 키 값과 데이터를 저장하는 자료 구조

Collision 충돌
Load Factor 적재율 : 해시 테이블의 크기(N) 대비 키의 개수(K) -> K/N
적재율이 1 초과인 해시 테이블의 경우 반드시 충돌 발생

만약, 충돌이 발생하지 않다고 할 경우 해시 테이블의 탐색, 삽입, 삭제 연산은 모두 O(1)에 수행 되지만 충돌이 발생할 경우 탐색과 삭제 연산이 최악에 O(K)만큼 걸리게 된다.
이는 같은 인덱스에 모든 키 값과 데이터가 저장된 경우 충돌이 전부 발생했음을 뜻한다. 따라서, 충돌을 최대한 줄여서 연산 속도를 빠르게 하는 것이 해시 테이블의 핵심인데 이에 중요하게 작용하는 것이 해시 알고리즘이다.
해시 알고리즘이 견고하지 못하게 되면 해시 함수로 도출된 값들이 같은 경우에 빈번하게 발생하게 되므로 잦은 충돌로 이어지게 되는 것이다.
충돌 완화 방법 : 해시 테이블의 구조 개선/ 해시 함수 개선

1) 해시 테이블의 구조 개선 = Chaining
   충돌이 발생했을 때 이를 동일한 Bucket에 저장하는데 이를 연결 리스트 형태로 저장하는 방법
   체이닝을 통해 해시테이블을 구현했을 때의 시간 복잡도
   삽입의 경우 연결 리스트에 추가하기만 하면 되니까 상수 시간인 O(1)이 걸리지만
   삭제의 경우 최악일 때 키 값의 개수인 K에 대해 O(K)가 걸리게 된다.
   하지만 최악의 경우 보다는 시간복잡도를 적재율을 이용해서 평균으로 표현하는 것이 일반적
   적재율을 알파라고 했을 때, 시간 복잡도는 a+1
   
![image](https://github.com/study-from-goorm/computer_science/assets/148074385/f19c804c-6e20-4f75-81ba-d8d29c775218)

3) Open Addressing
   동일한 주소에 다른 데이터가 있을 경우 다른 주소도 이용할 수 있게 하는 기법
   ![image](https://github.com/study-from-goorm/computer_science/assets/148074385/169809d6-7054-4c19-a058-578ffb2a3319)
